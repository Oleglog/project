1 В общем, класс — это абстракция, а объект — это конкретная реализация этой абстракции.

2 методы класса работают с классом, а self помогает методам работать с конкретными объектами.

3 Метод __init__:
Это специальный метод, который запускается, когда вы создаете новый объект. Он используется для установки начальных значений атрибутов объекта.

 Метод __del__:
Это специальный метод, который запускается, когда объект удаляется или больше не нужен. Он используется для очистки ресурсов, например, закрытия файлов.

4 __new__ создает объект, а __init__ инициализирует его. super() помогает работать с методами родительского класса.

5 Разница между staticmethod и classmethod:
staticmethod:
Это метод, который не принимает ни self, ни cls в качестве первого параметра. Он не зависит от состояния экземпляра или класса и может быть вызван как на уровне класса, так и на уровне экземпляра.
staticmethod используется, когда метод не требует доступа к атрибутам или методам класса или экземпляра. Он просто выполняет какую-то функцию, связанную с классом, но не требует информации о классе или экземпляре.
classmethod:
Это метод, который принимает класс (cls) в качестве первого параметра. Он может изменять состояние класса и доступен как на уровне класса, так и на уровне экземпляра.
staticmethod не имеет доступа к экземпляру или классу, в отличие от classmethod, который имеет доступ к классу через cls.

6 Инкапсуляция: Сеттеры и геттеры помогают скрыть внутренние детали реализации класса. Это позволяет изменять внутреннюю структуру без изменения интерфейса класса, что делает код более гибким и устойчивым к изменениям.
Контроль доступа: Сеттеры и геттеры позволяют контролировать доступ к атрибутам. Вы можете добавить логику проверки или валидации данных в сеттеры, чтобы гарантировать, что атрибуты всегда имеют допустимые значения.
Пример ситуации, когда использование защищенных атрибутов является более предпочтительным, чем использование публичных:
Сложные вычисления или валидация: Если атрибут требует сложной логики для установки или получения значения, лучше использовать защищенные атрибуты с сеттерами и геттерами. Это позволяет вам контролировать, как и когда атрибут изменяется.

7 Чем декоратор @property отличается от обычных методов?
Синтаксис: Декоратор @property позволяет вам использовать метод как атрибут, что делает код более чистым и удобным для чтения. Вместо вызова метода с круглыми скобками, вы можете обращаться к нему как к обычному атрибуту.
Инкапсуляция: Используя @property, вы можете скрыть внутреннюю логику получения значения, позволяя пользователю класса работать с атрибутом, не зная о том, как он реализован. Это позволяет вам изменять реализацию метода, не затрагивая код, который использует этот атрибут.

Какие преимущества даёт использование свойств по сравнению с прямым доступом к атрибутам?
Контроль доступа: Свойства позволяют контролировать, как и когда атрибуты могут быть изменены или получены. Вы можете добавлять логику в геттеры и сеттеры для валидации данных, что невозможно при прямом доступе к атрибутам.
Инкапсуляция: Свойства позволяют скрыть внутреннюю реализацию класса. Вы можете изменить способ хранения данных, не меняя интерфейс класса. Это делает код более устойчивым к изменениям.
Использование свойств с декоратором @property предоставляет больше контроля и гибкости по сравнению с прямым доступом к атрибутам.