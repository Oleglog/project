1 В общем, класс — это абстракция, а объект — это конкретная реализация этой абстракции.

2 методы класса работают с классом, а self помогает методам работать с конкретными объектами.

3 Метод __init__:
Это специальный метод, который запускается, когда вы создаете новый объект. Он используется для установки начальных значений атрибутов объекта.

 Метод __del__:
Это специальный метод, который запускается, когда объект удаляется или больше не нужен. Он используется для очистки ресурсов, например, закрытия файлов.

4 __new__ создает объект, а __init__ инициализирует его. super() помогает работать с методами родительского класса.

5 Разница между staticmethod и classmethod:
staticmethod:
Это метод, который не принимает ни self, ни cls в качестве первого параметра. Он не зависит от состояния экземпляра или класса и может быть вызван как на уровне класса, так и на уровне экземпляра.
staticmethod используется, когда метод не требует доступа к атрибутам или методам класса или экземпляра. Он просто выполняет какую-то функцию, связанную с классом, но не требует информации о классе или экземпляре.
classmethod:
Это метод, который принимает класс (cls) в качестве первого параметра. Он может изменять состояние класса и доступен как на уровне класса, так и на уровне экземпляра.
staticmethod не имеет доступа к экземпляру или классу, в отличие от classmethod, который имеет доступ к классу через cls.

6 Инкапсуляция: Сеттеры и геттеры помогают скрыть внутренние детали реализации класса. Это позволяет изменять внутреннюю структуру без изменения интерфейса класса, что делает код более гибким и устойчивым к изменениям.
Контроль доступа: Сеттеры и геттеры позволяют контролировать доступ к атрибутам. Вы можете добавить логику проверки или валидации данных в сеттеры, чтобы гарантировать, что атрибуты всегда имеют допустимые значения.
Пример ситуации, когда использование защищенных атрибутов является более предпочтительным, чем использование публичных:
Сложные вычисления или валидация: Если атрибут требует сложной логики для установки или получения значения, лучше использовать защищенные атрибуты с сеттерами и геттерами. Это позволяет вам контролировать, как и когда атрибут изменяется.

7 Чем декоратор @property отличается от обычных методов?
Синтаксис: Декоратор @property позволяет вам использовать метод как атрибут, что делает код более чистым и удобным для чтения. Вместо вызова метода с круглыми скобками, вы можете обращаться к нему как к обычному атрибуту.
Инкапсуляция: Используя @property, вы можете скрыть внутреннюю логику получения значения, позволяя пользователю класса работать с атрибутом, не зная о том, как он реализован. Это позволяет вам изменять реализацию метода, не затрагивая код, который использует этот атрибут.

Какие преимущества даёт использование свойств по сравнению с прямым доступом к атрибутам?
Контроль доступа: Свойства позволяют контролировать, как и когда атрибуты могут быть изменены или получены. Вы можете добавлять логику в геттеры и сеттеры для валидации данных, что невозможно при прямом доступе к атрибутам.
Инкапсуляция: Свойства позволяют скрыть внутреннюю реализацию класса. Вы можете изменить способ хранения данных, не меняя интерфейс класса. Это делает код более устойчивым к изменениям.
Использование свойств с декоратором @property предоставляет больше контроля и гибкости по сравнению с прямым доступом к атрибутам.

8 
Какие практические применения есть у магического метода __setattr__?
Валидация данных при установке значений атрибутов (например, проверка, что цена или вес не могут быть отрицательными).
Логирование или ведение истории изменений атрибутов.
Реализация атрибутов, которые могут изменяться только в определенных условиях.
В чем разница между __getattribute__ и __getattr__?
__getattribute__ вызывается всегда при доступе к любому атрибуту объекта (в том числе и существующему), и может привести к рекурсии.
__getattr__ вызывается только в случае, если атрибут не был найден стандартным способом (т.е. если его нет в объекте), и используется для обработки отсутствующих атрибутов или для реализации «умных» атрибутов.

9 Какие преимущества дает использование метода __call__ по сравнению с обычными функциями?

Сохранение состояния: В отличие от обычных функций, экземпляры класса с методом __call__ могут хранить состояние между вызовами, используя атрибуты экземпляра.
Гибкость: Можно добавить дополнительную логику, которая выполняется каждый раз при "вызове" объекта, включая выполнение до и после самой функции.
Использование в декораторах: Классы с методом __call__ часто используются в декораторах, что позволяет более гибко изменять поведение функций без изменения их исходного кода.

10 В чем разница между методами __str__ и __repr__?

__str__ предназначен для создания строки, которая будет понятна конечному пользователю и используется, например, при вызове print() или str().
__repr__ ориентирован на разработчика и должен предоставить более подробное и техническое описание объекта, которое часто можно использовать для воссоздания объекта.
Что произойдёт, если вызвать print(object) для объекта, у которого не определен метод __str__? Если метод __str__ не определен, Python использует метод __repr__ в качестве запасного варианта при вызове print() или str().

Какую задачу решает метод __abs__, и в каких случаях его реализация может быть полезной? Метод __abs__ используется для получения абсолютного значения объекта. Это полезно для числовых объектов или объектов, которые могут быть представлены числовыми значениями, таких как комплексные числа или значения с погрешностью.
Например, для чисел это просто возврат положительного значения.

11 Какой тип данных передается в other при вызове __add__ или __sub__?

В методах __add__ и __sub__ параметр other представляет собой объект, с которым производится операция. Например, если вы используете операторы + или - с объектами, то other — это второй операнд, с которым происходит операция (например, число, строка, список и т. д.).
Почему перегрузка операторов полезна при разработке на Python?

Перегрузка операторов делает код более интуитивно понятным и удобным в использовании.
Например, можно использовать стандартные операторы для работы с объектами, как если бы они были стандартными типами данных. Это улучшает читаемость и упрощает взаимодействие с объектами.

12 __eq__: Метод сравнивает книги по количеству страниц. Если количество страниц у двух книг одинаковое, возвращается True, иначе — False.
__ne__: Метод возвращает True, если количество страниц у книг не совпадает, и False, если они одинаковы.
__lt__: Метод проверяет, меньше ли количество страниц у одной книги по сравнению с другой.
__gt__: Метод проверяет, больше ли количество страниц у одной книги по сравнению с другой.
__le__: Метод проверяет, меньше или равно ли количество страниц у одной книги по сравнению с другой.
__ge__: Метод проверяет, больше или равно ли количество страниц у одной книги по сравнению с другой.

13 Почему используется тип данных tuple для хэширования, а не list?

tuple используется для хэширования, потому что это неизменяемый тип данных. Хэш-значение объекта не должно изменяться после его создания,
а списки (list) являются изменяемыми, и их хэш может измениться, если список будет изменён. Это делает список неподходящим для использования в качестве ключа в хэш-таблицах, таких как словари и множества.
Почему важно переопределять метод __hash__, если переопределён __eq__?

Если вы переопределяете метод __eq__, важно также переопределить метод __hash__, чтобы объекты, которые равны по __eq__,
имели одинаковые хэш-значения. Это необходимо для корректной работы объектов в коллекциях, основанных на хэшировании, таких как множества (set) и словари (dict). Если это правило нарушено, объекты, которые равны по содержимому, могут не работать должным образом в этих коллекциях.


14 Как Python определяет истинность объекта, если метод __bool__ отсутствует?

Если метод __bool__ отсутствует, Python будет искать метод __len__. Если метод __len__ также отсутствует, объект всегда будет считаться истинным (если только его класс не использует стандартное поведение).

Чем метод __bool__ отличается от __len__?

Метод __bool__ предназначен для явного определения, когда объект должен быть истинным или ложным на основе логики, специфичной для класса.
Метод __len__ возвращает длину объекта (например, количество элементов в списке или строке). Он используется как резервный механизм для проверки истинности, если метод __bool__ не определён. Если длина объекта равна 0, то объект считается ложным.
Как результат метода __bool__ влияет на условные конструкции (if, while и т. д.)?

Результат метода __bool__ определяет, будет ли объект считаться истинным или ложным при использовании его в условных конструкциях (например, в if или while). Если метод возвращает True, объект считается истинным, и условие выполняется. Если возвращается False, условие не выполняется.

15 Для чего используются методы __getitem__, __setitem__ и __delitem__ в Python?

Эти методы используются для предоставления доступа, изменения и удаления элементов объекта с помощью индексов или ключей, аналогично тому, как работают коллекции Python (например, списки и словари). С их помощью можно создать собственные структуры данных с индивидуальной логикой работы.
Что происходит, если вызвать obj[key] для объекта, у которого реализован только метод __getitem__?

Если реализован только метод __getitem__, попытка присвоить значение с помощью obj[key] = value вызовет ошибку, так как не существует метода __setitem__, который бы обрабатывал это присваивание. Аналогично, если попытаться удалить элемент с помощью del obj[key], произойдёт ошибка, так как отсутствует метод __delitem__.

16 Что такое итератор в Python?

Итератор в Python — это объект, который реализует метод __next__(), который возвращает следующий элемент последовательности. Когда элементы заканчиваются, он выбрасывает исключение StopIteration.

Чем итерируемый объект отличается от итератора?

Итерируемый объект — это объект, который может предоставить итератор, реализующий метод __next__. Он должен реализовывать метод __iter__().
Итератор — это объект, который предоставляет следующий элемент при вызове метода __next__(). Итератор сам по себе является итерируемым объектом.
Как остановить итерацию внутри метода __next__?

Для остановки итерации в методе __next__ необходимо выбросить исключение StopIteration. Это сигнализирует Python, что итерация завершена, и цикл завершится.